package Tetris.Game {	import Tetris.Core.*;	import Tetris.Game.Blocks.*;	import flash.utils.getDefinitionByName;	import flash.events.Event;	import flash.events.KeyboardEvent;		public class Blocks {		private static var grid = new Array();		private static var currentBlock = new Object();		private static var nextBlock = new Object();		private static var tempDrawables = new Array();		private static var stage;				/**		 * Start the game logic		 * @param Stage stage		 */		public static function initialize(stage) {			Blocks.stage = stage;						// Initialize objects			Blocks.currentBlock.color = '';			Blocks.currentBlock.coordinates = new Array();			Blocks.currentBlock.rotation = 0;						Blocks.nextBlock.color = '';			Blocks.nextBlock.coordinates = new Array();						// Set up grid			Blocks.prepareGrid(Config.grid.width, Config.grid.height);			// Generate initial block			Blocks.queueNextBlock();						// Listen for keydown events			stage.addEventListener(KeyboardEvent.KEY_DOWN, function(e: KeyboardEvent) {				switch (e.keyCode) {					// Left					case 37:						Blocks.moveSide(-1);					break;										// Up (rotate)					case 38:						Blocks.rotateCurrentBlock();					break;										// Right					case 39:						Blocks.moveSide(1);					break;										// Down					case 40:						Blocks.dropCurrentBlock();					break;				}			});		}		/**		 * Restart game		 */		public static function reset() {			// Set up grid			Blocks.prepareGrid(Config.grid.width, Config.grid.height);			// Generate initial block			Blocks.queueNextBlock();		}		/**		 * Move the current block to the side		 * @param Number deltaX		 */		private static function moveSide(deltaX) {			// Move to the side if requested and it's possible			if (Blocks.canMoveSide(deltaX)) {				Blocks.currentBlock.coordinates.forEach(function(point) {					point[0] += deltaX;				});			}		}		/**		 * Set up the grid at a specific size		 * @param Number width		 * @param Number height		 */		private static function prepareGrid(width, height) {			for (var x = 0; x < width; x++) {				Blocks.grid[x] = [];				for (var y = 0; y < height; y++) {					Blocks.grid[x][y] = null;				}			}		}		/**		 * Update the game logic		 * @param Number rate		 */		public static function update() {			// Spawn new blocks if none are falling			if (!Blocks.currentBlock.coordinates.length) {				Blocks.spawnBlocks();				return;			}			// Move down if we can			if (Blocks.canMoveDown()) {				Blocks.currentBlock.coordinates.forEach(function(point) {					point[1]++;				});			} else {				// Soft drop: 1 x number of blocks				UI.updateStats('score', Blocks.currentBlock.coordinates.length);				// Place the current block on the grid				Blocks.placeCurrentBlock();				// Are any of the rows full?				Blocks.detectFullLines();			}						Blocks.render();		}				/**		 * Render the frame		 */		public static function render() {						// Remove all blocks from stage			Blocks.tempDrawables.forEach(function(block) {				block.parent.removeChild(block);			});						// Reset array			Blocks.tempDrawables = new Array();						// Add blocks to stage			for (var x in Blocks.grid) {				for (var y in Blocks.grid[x]) {					if (Blocks.grid[x][y]) {						trace(x + "; " + y);						Blocks.drawBlock(Blocks.grid[x][y], x, y);					}				}			}						// Draw user blocks			Blocks.currentBlock.coordinates.forEach(function(block) {					Blocks.drawBlock(Blocks.currentBlock.color, block[0], block[1]);			});		}				/**		 * Queue a draw call of the block		 * @param String color		 * @param Number x		 * @param Number y		 */		private static function drawBlock(color, x, y) {			var color = Utils.upperCase(color);			var blockClass:Class = getDefinitionByName("Tetris.Game.Blocks.Block" + color) as Class;			var myInstance: Block = new blockClass();			Blocks.tempDrawables.push(myInstance);			Blocks.tempDrawables[Blocks.tempDrawables.length - 1].x = Utils.translate(x);			Blocks.tempDrawables[Blocks.tempDrawables.length - 1].y = Utils.translate(y);			Blocks.stage.addChild(Blocks.tempDrawables[Blocks.tempDrawables.length - 1]);		}		/**		 * Detect full lines and clear them for score		 */		private static function detectFullLines() {			trace('Checking for full lines');			var row = Config.grid.height - 1;			// Loop rows			while (row >= 0) {				var cleared = true;				// Loop through every block in the row				for (var x = 0; x < Config.grid.width; x++) {					if (!Blocks.grid[x][row]) {						cleared = false;					}				}				if (cleared) {					Blocks.clearLine(row);					break;				}				row--;			}		}		/**		 * Clear a line		 * @param Number y		 */		private static function clearLine(y) {			// Clear line			for (var x1 in Blocks.grid) {				Blocks.grid[x1][y] = null;			}			// Update score			UI.updateStats('lines');			UI.updateStats('score', 100); // TODO: special score for multi-line etc?			while (y--) {				for (var x in Blocks.grid) {					if (Blocks.grid[x][y]) {						trace('Moving (' + x + '; ' + y + ') to (' + x + '; ' + (y + 1) + ')');						Blocks.grid[x][y + 1] = Blocks.grid[x][y];						Blocks.grid[x][y] = null;					}				}			}			// Detect new full lines after applying gravity			Blocks.detectFullLines();		}		/**		 * Make the current block fall until it collides		 */		private static function fallUntilCollision() {			while (Blocks.canMoveDown()) {				Blocks.currentBlock.coordinates.forEach(function(point) {					point[1]++;				});			}		}		/**		 * Check if the current blocks can fall down by one block		 * @param Object blocks		 * @return Boolean		 */		private static function canMoveDown(blocks = false) {			var x, y;			if (!blocks) {				blocks = Blocks.currentBlock.coordinates;			}			for (var point in blocks) {				x = blocks[point][0];				y = blocks[point][1];				if (Collision.test(Blocks.grid, { x: x, y: y + 1 }) || Collision.testBounds({x: x, y: y + 1 })) {					trace('Collided at (' + x + '; ' + (y + 1) + ')', 'Game/Blocks');					return false;				}			}			return true;		}		/**		 * Check if the current blocks can move to the requested side		 * @param Number deltaX		 * @return Boolean		 */		private static function canMoveSide(deltaX) {			var x, y;			for (var point in Blocks.currentBlock.coordinates) {				x = Blocks.currentBlock.coordinates[point][0];				y = Blocks.currentBlock.coordinates[point][1];				if (Collision.test(Blocks.grid, { x: x + deltaX, y: y }) || Collision.testBounds({x: x + deltaX, y: y })) {					trace('Failed to move to side (' + (x + deltaX) + '; ' + y + ')', 'Game/Blocks');					return false;				}			}			return true;		}		/**		 * Place the current block		 */		private static function placeCurrentBlock() {			// Copy the blocks to the grid			Blocks.currentBlock.coordinates.forEach(function(point) {				Blocks.grid[point[0]][point[1]] = Blocks.currentBlock.color;			});					// Trigger a new block to spawn			Blocks.currentBlock.color = '';			Blocks.currentBlock.coordinates = new Array();			Blocks.currentBlock.rotation = 0;		}		/**		 * Spawn a new set of user controllable blocks		 */		private static function spawnBlocks() {			trace('Spawning new blocks (' + Blocks.nextBlock.color + ')', 'Game/Blocks');			Blocks.currentBlock.color = Utils.copy(Blocks.nextBlock.color);			var formation = Utils.copy(Blocks.nextBlock.coordinates);			Blocks.currentBlock.coordinates = Utils.centerHorizontally(formation);			Blocks.currentBlock.rotation = 0;			// Check for collisions			var x, y;			for (var point in Blocks.currentBlock.coordinates) {				x = Blocks.currentBlock.coordinates[point][0];				y = Blocks.currentBlock.coordinates[point][1];				if (Collision.test(Blocks.grid, { x: x, y: y })) {					trace('Spawn-collided at (' + x + '; ' + (y + 1) + ')', 'Game/Blocks');					UI.lose();					return;				}			}			Blocks.queueNextBlock();		}		/**		 * Queue a new block		 */		private static function queueNextBlock() {			Blocks.nextBlock.color = Utils.randomItem(Config.blockColors);			Blocks.nextBlock.coordinates = Utils.copy(Config.blockFormations[Blocks.nextBlock.color]);			// Update UI			UI.setNextBlock(Blocks.nextBlock.color, Blocks.nextBlock.coordinates);		}			/**		 * Rotate the current block		 */		private static function rotateCurrentBlock() {			Blocks.currentBlock.rotation++;			var baseCoordinates = Utils.copy(Config.blockFormations[Blocks.currentBlock.color]);			baseCoordinates = Blocks.rotate(baseCoordinates, Blocks.currentBlock.rotation);			var deltaX = Blocks.currentBlock.coordinates[0][0];			var deltaY = Blocks.currentBlock.coordinates[0][1];			var canRotate = true;			baseCoordinates.forEach(function(point) {				point[0] += deltaX;				point[1] += deltaY;				if (Collision.test(Blocks.grid, { x: point[0], y: point[1] }) || Collision.testBounds({ x: point[0], y: point[1] })) {					trace('Failed to rotate ' + (Blocks.currentBlock.rotation * 90) + 'deg (' + (point[0]) + '; ' + point[1] + ')', 'Game/Blocks');					canRotate = false;				}			});			if (!canRotate) {				Blocks.currentBlock.rotation--;				return;			}			Blocks.currentBlock.coordinates = baseCoordinates;		}				/**,		 * Rotate a set of coordinates in 90 deg steps		 * @param Array formation		 * @param Number turns		 * @return Array newFormation		 */		private static function rotate(formation, turns = 1) {			var formationCopy = Utils.copy(formation);			// Perform the operation a certain number of times			for (var i = 0; i < turns; i++) {				// Loop through the set of coordinates				formationCopy.forEach(function(c) {					// Rotate 90 deg according to (x, y) -> (-y, x)					var tempX = c[0];					c[0] = -c[1];					c[1] = tempX;					// Replace -0 by 0 for clarity					if (c[0] === -0) c[0] = 0;					if (c[1] === -0) c[1] = 0;				});			}			return formationCopy;		}				/**		 * Drop current block		 */		private static function dropCurrentBlock() {			Blocks.fallUntilCollision();			// Hard drop: 2 x number of blocks			UI.updateStats('score', 2 * Blocks.currentBlock.coordinates.length);			Blocks.placeCurrentBlock();			Blocks.detectFullLines();		}	}}